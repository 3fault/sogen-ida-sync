#pragma once

#include <ida-plugin/ida_plugin.hpp>
#include <network/tcp_client_socket.hpp>
#include <pro.h>

static ssize_t dbg_hook_cb(void* user_data, int notification_code, va_list va)
{
    auto* self = static_cast<plugin_ctx_t*>(user_data);

    // https://cpp.docs.hex-rays.com/dbg_8hpp.html#ac67a564945a2c1721691aa2f657a908c
    switch (notification_code)
    {
    case dbg_notification_t::dbg_process_start:
        break;
    case dbg_notification_t::dbg_process_exit:
        break;
    case dbg_notification_t::dbg_process_attach:
        break;
    case dbg_notification_t::dbg_process_detach:
        break;
    case dbg_notification_t::dbg_suspend_process:
        break;

    // Investigate to see if these naturally get generated by gdb stub
    case dbg_notification_t::dbg_library_load:
        break;
    case dbg_notification_t::dbg_library_unload:
        break;
    case dbg_notification_t::dbg_information:
        break;
    }

    return 0;
}

static ssize_t idd_hook_cb(void* user_data, int notification_code, va_list va)
{
    auto* self = static_cast<plugin_ctx_t*>(user_data);

    switch (notification_code)
    {
    // Initialize debugger.
    case debugger_t::ev_init_debugger: {
        // Ensure expression evaluation order
        const auto* hostname = va_arg(va, const char*);
        const auto portnum = va_arg(va, int);
        const auto* password = va_arg(va, const char*);
        auto* errbuf = va_arg(va, qstring*);

        // Initialize the TCP client and set the listening state
        const bool success = handle_ev_init_debugger(self->client_, hostname, portnum, password, errbuf);
        self->listening_ = success;

        return success ? DRC_OK : DRC_FAILED;
    }
    // Terminate debugger.
    case debugger_t::ev_term_debugger: {
        self->listening_ = false;
    }
    // Get information on the memory ranges.
    case debugger_t::ev_get_memory_info: {
        break;
    }
    default:
        break;
    }

    // Passive listener.
    return DRC_NONE;
}

// std::expected https://stackoverflow.com/a/32127664
static bool handle_ev_init_debugger(network::tcp_client_socket& client, const char* hostname, int portnum,
                                    const char* password, qstring* errbuf)
{
    UNUSED(password, errbuf);

    constexpr const auto SOGEN_PORT = 28960;
    constexpr const auto SOGEN_SYNC_PORT = 28961;

    // TODO:
    // Implement settings window that will allow detecting a certain port
    if (portnum == SOGEN_PORT)
    {
        // Attempt to connect to sync server
        return initialize_tcp_client(client, hostname, SOGEN_SYNC_PORT);
    }

    // The sync server was not connected
    return false;
}
