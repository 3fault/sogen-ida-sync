#include "ida_plugin.hpp"
#include "events.hpp"
#include "idd.hpp"
#include "network/socket.hpp"
#include "pro.h"

#include <atomic>
#include <exception>
#include <ida.hpp>
#include <idp.hpp>
#include <loader.hpp>
#include <funcs.hpp>
#include <netnode.hpp>
// #include <kernwin.hpp>
#include <dbg.hpp>

#include <cstdlib>
#include <cassert>

#include <string>
#include <algorithm>
#include <ranges>
#include <string_view>

#include <utils/string.hpp>
#include <platform/compiler.hpp>
#include <network/tcp_client_socket.hpp>

// GReAT thoughts: Awesome IDA Pro plugins: https://securelist.com/great-ida-pro-plugins/97898/
// https://docs.hex-rays.com/developer-guide/c++-sdk/c++-sdk-examples#ex_events1
// https://cpp.docs.hex-rays.com/group__dbg__funcs.html
// hook_event_listener(HT_DBG, this);
// hook_to_notification_point(HT_DBG, ht_dbg_callback);
// https://docs.hex-rays.com/developer-guide/c++-sdk/c++-sdk-examples#mtsample

// Define the class that inherits from plugmod_t
class plugin_ctx_t : public plugmod_t /*, public event_listener_t*/
{
  public:
    // Constructor
    plugin_ctx_t()
    {
        ida_log(LogLevel::Info, "Constructor called.");

        // Subscribe to Debugger Control (HT_DBG) and Debugger Plugin (HT_IDD) events.
        hook_to_notification_point(HT_DBG, dbg_hook_cb, this); // [`dbg_notification_t`]
        hook_to_notification_point(HT_IDD, idd_hook_cb, this); // [`debugger_t::event_t`]
    }

    // Destructor
    ~plugin_ctx_t() override
    {
        ida_log(LogLevel::Info, "Destructor called.");

        // Unhook from the debugger and debugger plugin.
        unhook_from_notification_point(HT_DBG, dbg_hook_cb, this);
        unhook_from_notification_point(HT_IDD, idd_hook_cb, this);
    }

    // static ssize_t dbg_hook_cb(void* user_data, int notification_code, va_list va)
    // {
    //     auto* self = static_cast<plugin_ctx_t*>(user_data);

    //     // https://cpp.docs.hex-rays.com/dbg_8hpp.html#ac67a564945a2c1721691aa2f657a908c
    //     switch (notification_code)
    //     {
    //     case dbg_notification_t::dbg_process_start:
    //         break;
    //     case dbg_notification_t::dbg_process_exit:
    //         break;
    //     case dbg_notification_t::dbg_process_attach:
    //         break;
    //     case dbg_notification_t::dbg_process_detach:
    //         break;
    //     case dbg_notification_t::dbg_suspend_process:
    //         break;

    //     // Investigate to see if these naturally get generated by gdb stub
    //     case dbg_notification_t::dbg_library_load:
    //         break;
    //     case dbg_notification_t::dbg_library_unload:
    //         break;
    //     case dbg_notification_t::dbg_information:
    //         break;
    //     }

    //     return 0;
    // }

    // static ssize_t idd_hook_cb(void* user_data, int notification_code, va_list va)
    // {
    //     auto* self = static_cast<plugin_ctx_t*>(user_data);

    //     switch (notification_code)
    //     {
    //     // Initialize debugger.
    //     case debugger_t::ev_init_debugger: {
    //         // Ensure expression evaluation order
    //         const auto* hostname = va_arg(va, const char*);
    //         const auto portnum = va_arg(va, int);
    //         const auto* password = va_arg(va, const char*);
    //         auto* errbuf = va_arg(va, qstring*);

    //         // Initialize the TCP client and set the listening state
    //         const bool success = handle_ev_init_debugger(self->client_, hostname, portnum, password, errbuf);
    //         self->listening_ = success;

    //         return success ? DRC_OK : DRC_FAILED;
    //     }
    //     // Terminate debugger.
    //     case debugger_t::ev_term_debugger: {
    //         self->listening_ = false;
    //     }
    //     // Get information on the memory ranges.
    //     case debugger_t::ev_get_memory_info: {
    //         break;
    //     }
    //     default:
    //         break;
    //     }

    //     // Passive listener.
    //     return DRC_NONE;
    // }

    static bool process_packet(const std::string_view packet)
    {
        if (packet.empty())
        {
            return true;
        }
        ida_log(LogLevel::Debug, "Processing '{}'", std::string(packet));

        const auto tokens = split_packet(packet, ':');

        const auto parse_int = [&](const auto& str, int base = 10) {
            try
            {
                return std::optional(std::stoull(str, nullptr, base));
            }
            catch (const std::exception& e)
            {
                ida_log(LogLevel::Error, "Could not parse %s as base-%d integer: %s", str, base, packet);
                return std::optional<size_t>{};
            }
        };

        const auto& command = tokens[0];

        if (command == "m+")
        {
            const auto& mod_name = tokens[1];

            const auto base_addr = parse_int(tokens[2], 16);
            const auto len = parse_int(tokens[3]);
            if (!base_addr.has_value() || !len.has_value())
            {
                return false;
            }

            const auto dll_path = std::format(R"(C:\Windows\System32\{})", mod_name);

            add_module_req_t add_module_req{dll_path.c_str(), base_addr.value(), len.value()}; // mod_name
            execute_sync(add_module_req, MFF_WRITE);

            /*
            // Create an 'add segment' request and wait for it to be executed on the main
			// thread

            add_segm_req_t add_segm_req{mod_name.c_str(), base_addr.value(), len.value()}; execute_sync(add_segm_req,
            MFF_WRITE);

            const auto dll_path = std::format(R"(C:\Windows\System32\{})", tokens[1]);

            // Create an 'pdb loader' request and wait for it to be executed on the main
            // thread
            load_pdb_t pdb_loader{dll_path.c_str(), base_addr.value()};
            execute_sync(pdb_loader, MFF_WRITE);
            */

            return true;
        }
        else if (command == "s+")
        {
            const auto& mod_name = tokens[1];
            const auto base_addr = parse_int(tokens[2], 16);
            const auto len = parse_int(tokens[3]);
            const auto& perms = tokens[4];

            if (!base_addr.has_value() || !len.has_value())
            {
                return false;
            }

            add_segm_req_t add_segm_req{mod_name.c_str(), base_addr.value(), len.value(), perms.c_str()};
            execute_sync(add_segm_req, MFF_WRITE);
        }

        return false;
    }

    static int recieve_packet(void* ud)
    {
        auto* client = static_cast<network::tcp_client_socket*>(ud);
        // qthread_t tid = qthread_self();

        while (true)
        {
            const auto packet = client->receive();
            if (!packet)
            {
                break;
            }

            for (const auto& view : packet.value() | std::views::split(';'))
            {
                process_packet(std::string_view(view.begin(), view.end()));
            }

            qsleep(100);
        }

        return 0;
    }

    // Method that gets called when the plugin is activated
    bool idaapi run(size_t arg) override
    {
        ida_log(LogLevel::Info, "MyPlugmod.run() called with arg: %d", arg);

        const auto address = network::address{"127.0.0.1:28961", AF_INET};
        client_ = network::tcp_client_socket{address.get_family()};

        if (!client_.connect(address))
        {
            const auto error = GET_SOCKET_ERROR();
            ida_log(LogLevel::Error, "Could not connect to server: %d", error);
            return false;
        };

        ida_log(LogLevel::Info, "Connected!");

        // Setup packet recieve loop on another thread
        t_ = qthread_create(recieve_packet, reinterpret_cast<void*>(&client_));
        n_childs_++;

        return true;
    }

  private:
    network::tcp_client_socket client_;
    std::atomic_bool listening_ = false;

    qthread_t t_;
    ssize_t n_childs_ = 0;
};

static plugmod_t* idaapi init()
{
    return new plugin_ctx_t();
}

plugin_t PLUGIN = {
    .version = IDP_INTERFACE_VERSION,
    .flags = PLUGIN_MULTI,  // plugin flags
    .init = init,           // initialize
    .term = nullptr,        // terminate. this pointer can be nullptr
    .run = nullptr,         // invoke the plugin
    .comment = nullptr,     // long comment about the plugin
    .help = nullptr,        // multiline help about the plugin
    .wanted_name = "Sogen", // the preferred short name of the plugin
    .wanted_hotkey = ""     // the preferred hotkey to run the plugin
};
